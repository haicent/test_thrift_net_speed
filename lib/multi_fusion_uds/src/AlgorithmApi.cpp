/**
 * Autogenerated by Thrift Compiler (0.17.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mfu/AlgorithmApi.h"

namespace fusion_api {


AlgorithmApi_multiDeviceFusion_args::~AlgorithmApi_multiDeviceFusion_args() noexcept {
}


uint32_t AlgorithmApi_multiDeviceFusion_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->cml.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              std::string _key11;
              xfer += iprot->readString(_key11);
              std::vector<CameraTarget> & _val12 = this->cml[_key11];
              {
                _val12.clear();
                uint32_t _size13;
                ::apache::thrift::protocol::TType _etype16;
                xfer += iprot->readListBegin(_etype16, _size13);
                _val12.resize(_size13);
                uint32_t _i17;
                for (_i17 = 0; _i17 < _size13; ++_i17)
                {
                  xfer += _val12[_i17].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.cml = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->rml.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              std::string _key23;
              xfer += iprot->readString(_key23);
              std::vector<RadarTarget> & _val24 = this->rml[_key23];
              {
                _val24.clear();
                uint32_t _size25;
                ::apache::thrift::protocol::TType _etype28;
                xfer += iprot->readListBegin(_etype28, _size25);
                _val24.resize(_size25);
                uint32_t _i29;
                for (_i29 = 0; _i29 < _size25; ++_i29)
                {
                  xfer += _val24[_i29].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.rml = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->lml.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _ktype31;
            ::apache::thrift::protocol::TType _vtype32;
            xfer += iprot->readMapBegin(_ktype31, _vtype32, _size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              std::string _key35;
              xfer += iprot->readString(_key35);
              std::vector<LidarTarget> & _val36 = this->lml[_key35];
              {
                _val36.clear();
                uint32_t _size37;
                ::apache::thrift::protocol::TType _etype40;
                xfer += iprot->readListBegin(_etype40, _size37);
                _val36.resize(_size37);
                uint32_t _i41;
                for (_i41 = 0; _i41 < _size37; ++_i41)
                {
                  xfer += _val36[_i41].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.lml = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlgorithmApi_multiDeviceFusion_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlgorithmApi_multiDeviceFusion_args");

  xfer += oprot->writeFieldBegin("cml", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->cml.size()));
    std::map<std::string, std::vector<CameraTarget> > ::const_iterator _iter42;
    for (_iter42 = this->cml.begin(); _iter42 != this->cml.end(); ++_iter42)
    {
      xfer += oprot->writeString(_iter42->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter42->second.size()));
        std::vector<CameraTarget> ::const_iterator _iter43;
        for (_iter43 = _iter42->second.begin(); _iter43 != _iter42->second.end(); ++_iter43)
        {
          xfer += (*_iter43).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rml", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->rml.size()));
    std::map<std::string, std::vector<RadarTarget> > ::const_iterator _iter44;
    for (_iter44 = this->rml.begin(); _iter44 != this->rml.end(); ++_iter44)
    {
      xfer += oprot->writeString(_iter44->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter44->second.size()));
        std::vector<RadarTarget> ::const_iterator _iter45;
        for (_iter45 = _iter44->second.begin(); _iter45 != _iter44->second.end(); ++_iter45)
        {
          xfer += (*_iter45).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lml", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->lml.size()));
    std::map<std::string, std::vector<LidarTarget> > ::const_iterator _iter46;
    for (_iter46 = this->lml.begin(); _iter46 != this->lml.end(); ++_iter46)
    {
      xfer += oprot->writeString(_iter46->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter46->second.size()));
        std::vector<LidarTarget> ::const_iterator _iter47;
        for (_iter47 = _iter46->second.begin(); _iter47 != _iter46->second.end(); ++_iter47)
        {
          xfer += (*_iter47).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


AlgorithmApi_multiDeviceFusion_pargs::~AlgorithmApi_multiDeviceFusion_pargs() noexcept {
}


uint32_t AlgorithmApi_multiDeviceFusion_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AlgorithmApi_multiDeviceFusion_pargs");

  xfer += oprot->writeFieldBegin("cml", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->cml)).size()));
    std::map<std::string, std::vector<CameraTarget> > ::const_iterator _iter48;
    for (_iter48 = (*(this->cml)).begin(); _iter48 != (*(this->cml)).end(); ++_iter48)
    {
      xfer += oprot->writeString(_iter48->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter48->second.size()));
        std::vector<CameraTarget> ::const_iterator _iter49;
        for (_iter49 = _iter48->second.begin(); _iter49 != _iter48->second.end(); ++_iter49)
        {
          xfer += (*_iter49).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rml", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->rml)).size()));
    std::map<std::string, std::vector<RadarTarget> > ::const_iterator _iter50;
    for (_iter50 = (*(this->rml)).begin(); _iter50 != (*(this->rml)).end(); ++_iter50)
    {
      xfer += oprot->writeString(_iter50->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter50->second.size()));
        std::vector<RadarTarget> ::const_iterator _iter51;
        for (_iter51 = _iter50->second.begin(); _iter51 != _iter50->second.end(); ++_iter51)
        {
          xfer += (*_iter51).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lml", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*(this->lml)).size()));
    std::map<std::string, std::vector<LidarTarget> > ::const_iterator _iter52;
    for (_iter52 = (*(this->lml)).begin(); _iter52 != (*(this->lml)).end(); ++_iter52)
    {
      xfer += oprot->writeString(_iter52->first);
      {
        xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter52->second.size()));
        std::vector<LidarTarget> ::const_iterator _iter53;
        for (_iter53 = _iter52->second.begin(); _iter53 != _iter52->second.end(); ++_iter53)
        {
          xfer += (*_iter53).write(oprot);
        }
        xfer += oprot->writeListEnd();
      }
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


AlgorithmApi_multiDeviceFusion_result::~AlgorithmApi_multiDeviceFusion_result() noexcept {
}


uint32_t AlgorithmApi_multiDeviceFusion_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AlgorithmApi_multiDeviceFusion_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("AlgorithmApi_multiDeviceFusion_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


AlgorithmApi_multiDeviceFusion_presult::~AlgorithmApi_multiDeviceFusion_presult() noexcept {
}


uint32_t AlgorithmApi_multiDeviceFusion_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void AlgorithmApiClient::multiDeviceFusion(const std::map<std::string, std::vector<CameraTarget> > & cml, const std::map<std::string, std::vector<RadarTarget> > & rml, const std::map<std::string, std::vector<LidarTarget> > & lml)
{
  send_multiDeviceFusion(cml, rml, lml);
  recv_multiDeviceFusion();
}

void AlgorithmApiClient::send_multiDeviceFusion(const std::map<std::string, std::vector<CameraTarget> > & cml, const std::map<std::string, std::vector<RadarTarget> > & rml, const std::map<std::string, std::vector<LidarTarget> > & lml)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("multiDeviceFusion", ::apache::thrift::protocol::T_CALL, cseqid);

  AlgorithmApi_multiDeviceFusion_pargs args;
  args.cml = &cml;
  args.rml = &rml;
  args.lml = &lml;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void AlgorithmApiClient::recv_multiDeviceFusion()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("multiDeviceFusion") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  AlgorithmApi_multiDeviceFusion_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

bool AlgorithmApiProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void AlgorithmApiProcessor::process_multiDeviceFusion(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("AlgorithmApi.multiDeviceFusion", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "AlgorithmApi.multiDeviceFusion");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "AlgorithmApi.multiDeviceFusion");
  }

  AlgorithmApi_multiDeviceFusion_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "AlgorithmApi.multiDeviceFusion", bytes);
  }

  AlgorithmApi_multiDeviceFusion_result result;
  try {
    iface_->multiDeviceFusion(args.cml, args.rml, args.lml);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "AlgorithmApi.multiDeviceFusion");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("multiDeviceFusion", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "AlgorithmApi.multiDeviceFusion");
  }

  oprot->writeMessageBegin("multiDeviceFusion", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "AlgorithmApi.multiDeviceFusion", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > AlgorithmApiProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< AlgorithmApiIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< AlgorithmApiIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new AlgorithmApiProcessor(handler));
  return processor;
}

void AlgorithmApiConcurrentClient::multiDeviceFusion(const std::map<std::string, std::vector<CameraTarget> > & cml, const std::map<std::string, std::vector<RadarTarget> > & rml, const std::map<std::string, std::vector<LidarTarget> > & lml)
{
  int32_t seqid = send_multiDeviceFusion(cml, rml, lml);
  recv_multiDeviceFusion(seqid);
}

int32_t AlgorithmApiConcurrentClient::send_multiDeviceFusion(const std::map<std::string, std::vector<CameraTarget> > & cml, const std::map<std::string, std::vector<RadarTarget> > & rml, const std::map<std::string, std::vector<LidarTarget> > & lml)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("multiDeviceFusion", ::apache::thrift::protocol::T_CALL, cseqid);

  AlgorithmApi_multiDeviceFusion_pargs args;
  args.cml = &cml;
  args.rml = &rml;
  args.lml = &lml;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void AlgorithmApiConcurrentClient::recv_multiDeviceFusion(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("multiDeviceFusion") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      AlgorithmApi_multiDeviceFusion_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

